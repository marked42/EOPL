#lang eopl

(require racket/lazy-require racket/list "expression.rkt")
(provide (all-defined-out))

(define (cps-of-program prog)
  (eopl:pretty-print prog)
  (cases program prog
    (a-program (exp1)
               (let ((exp2 (cps-of-exp exp1 (lambda (exp)
                                              ; exp is gurranteed to be simple
                                              ;   (make-tfexp-from-simple exp)
                                              (make-send-to-cont (end-cont) exp)
                                              ))))
                 (eopl:pretty-print exp2)
                 exp2
                 )
               )
    )
  )

(define (make-tfexp-from-simple simple)
  (simple-exp->exp simple)
  )

(define (end-cont)
  (let ((var (fresh-identifier 'var)))
    (cps-proc-exp (list var) (make-tfexp-from-simple (cps-var-exp var)))
  )
)

(define (make-send-to-cont k-exp exp)
  (cps-call-exp k-exp (list exp))
)

(define fresh-identifier
  (let ((sn 0))
    (lambda (identifier)
      (set! sn (+ sn 1))
      (string->symbol
       (string-append
        (symbol->string identifier)
        ; this can't appear in an input identifier
        "%"
        (number->string sn))))))

(define (cps-of-exp exp cont)
  (cases expression exp
    (const-exp (num) (cps-of-const-exp num cont))
    (var-exp (var) (cps-of-var-exp var cont))
    (diff-exp (exp1 exp2)
              (cps-of-diff-exp exp1 exp2 cont)
              )
    (zero?-exp (exp1)
               (cps-of-zero?-exp exp1 cont)
               )
    (if-exp (exp1 exp2 exp3)
            (cps-of-if-exp exp1 exp2 exp3 cont)
            )
    (proc-exp (vars body)
              (cps-of-proc-exp vars body cont)
              )
    (call-exp (rator rands)
              (cps-of-call-exp rator rands cont)
              )
    (sum-exp (exps)
             (cps-of-sum-exp exps cont)
             )
    (let-exp (var1 exp1 body)
             (cps-of-let-exp var1 exp1 body cont)
             )
    (letrec-exp (p-names b-varss p-bodies body)
                (cps-of-letrec-exp p-names b-varss p-bodies body cont)
                )
    (else (eopl:error 'cps-of-exp "invalid expression type ~s " exp))
    )
  )

(define (cps-of-const-exp num cont)
  (cont (cps-const-exp num))
)

(define (cps-of-var-exp var cont)
  (cont (cps-var-exp var))
)

(define (cps-of-diff-exp exp1 exp2 cont)
  (cps-of-exp exp1 (lambda (simple1)
                      (cps-of-exp exp2 (lambda (simple2)
                                        (cont (cps-diff-exp simple1 simple2))
                                        ))
                      ))
)

(define (cps-of-zero?-exp exp1 cont)
  (cps-of-exp exp1 (lambda (simple1)
                    (cont (cps-zero?-exp simple1))
                    ))
)

(define (cps-of-if-exp exp1 exp2 exp3 cont)
  (cps-of-exp exp1 (lambda (simple1)
                      (cps-if-exp simple1
                                  (cps-of-exp exp2 cont)
                                  (cps-of-exp exp3 cont)
                                  ))
              )
)

(define (cps-of-proc-exp vars body cont)
  (let ((k (fresh-identifier 'k)))
    (cont
      (cps-proc-exp (append vars (list k))
                    (cps-of-exp body (lambda (simple)
                                      (cps-call-exp (cps-var-exp k) (list simple))
                                      ))
                    )
      )
    )
  ;   (cps-of-exp body (lambda (simple)
  ;                      (let ((k (fresh-identifier 'k)))
  ;                        (cont
  ;                         (cps-proc-exp (append vars (list k))
  ;                                       (cps-call-exp (cps-var-exp k) (list simple))
  ;                                       )
  ;                         )
  ;                        )
  ;                      ))
)

(define (cps-of-call-exp rator rands cont)
  (cps-of-exps
    (cons rator rands)
    (lambda (simples)
      (let ((var (fresh-identifier 'var)))
        (cps-call-exp
        (car simples)
        (append
          (cdr simples)
          (list
          (cps-proc-exp (list var)
                        (cont (cps-var-exp var))
                        )
          )
          )
        )
        ))
    )
)

(define (cps-of-sum-exp exps cont)
  (cps-of-exps exps (lambda (simples)
                      (cont (cps-sum-exp simples))
                      ))
)

(define (cps-of-letrec-exp p-names b-varss p-bodies body cont)
  (let ((k-exps (map (lambda (name) (fresh-identifier 'k)) p-names)))
    (cps-letrec-exp
      p-names
      (map (lambda (b-vars k) (append b-vars (list k))) b-varss k-exps)
      (map (lambda (p-body k)
            (cps-of-exp p-body (lambda (simple)
                                  (cps-call-exp (cps-var-exp k) (list simple))
                                  )
                        )
            ) p-bodies k-exps)
      (cps-of-exp body (lambda (simple)
                        (cont simple)
                        ))
      )
    )
)

(define (cps-of-let-exp var1 exp1 body cont)
  (cps-of-exp exp1 (lambda (simple1)
                    (cps-let-exp var1 simple1
                                  (cps-of-exp body (lambda (simple)
                                                    (cont simple)
                                                    ))
                                  )
                    ))
)

(define (cps-of-exps exps cont)
  (if (null? exps)
      (cont '())
      (let ((first (car exps)) (rest (cdr exps)))
        (cps-of-exp first (lambda (simple1)
                            (cps-of-exps rest (lambda (simples)
                                                (cont (cons simple1 simples))
                                                ))
                            ))
        )
      )
  )
