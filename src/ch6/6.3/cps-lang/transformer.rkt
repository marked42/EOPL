#lang eopl

(require racket/lazy-require racket/list "expression.rkt")
(provide (all-defined-out))

(define (cps-of-program prog)
  (eopl:pretty-print prog)
  (cases program prog
    (a-program (exp1)
               (let ((exp2 (cps-of-exp exp1 (lambda (exp)
                                              ; exp is gurranteed to be simple
                                              ;   (wrap-as-tfexp exp)
                                              (wrap-in-end-cont exp)
                                              ))))
                 (eopl:pretty-print exp2)
                 ;  (wrap-in-end-cont exp2)
                 exp2
                 )
               )
    )
  )

(define (wrap-as-tfexp simple)
  (simple-exp->exp simple)
  )

(define (wrap-in-end-cont exp2)
  (let ((var (fresh-identifier 'var)))
    (let ((end-cont (cps-proc-exp (list var) (simple-exp->exp (cps-var-exp var)))))
      (cps-call-exp end-cont (list exp2))
      )
    )
  )

(define fresh-identifier
  (let ((sn 0))
    (lambda (identifier)
      (set! sn (+ sn 1))
      (string->symbol
       (string-append
        (symbol->string identifier)
        ; this can't appear in an input identifier
        "%"
        (number->string sn))))))

; (define (make-send-to-cont k-exp exp)
;     (cps-call-exp k-exp (list exp))
; )

(define (cps-of-exp exp cont)
  (cases expression exp
    (const-exp (num) (cont (cps-const-exp num)))
    (var-exp (var) (cont (cps-var-exp var)))
    (diff-exp (exp1 exp2)
              (cps-of-exp exp1 (lambda (simple1)
                                 (cps-of-exp exp2 (lambda (simple2)
                                                    (cont (cps-diff-exp simple1 simple2))
                                                    ))
                                 ))
              )
    (zero?-exp (exp1)
               (cps-of-exp exp1 (lambda (simple1)
                                  (cont (cps-zero?-exp simple1))
                                  ))
               )
    (if-exp (exp1 exp2 exp3)
            (cps-of-exp exp1 (lambda (simple1)
                               (cps-if-exp simple1
                                           (cps-of-exp exp2 cont)
                                           (cps-of-exp exp3 cont)
                                           ))
                        )
            )
    (proc-exp (vars body)
              (let ((k (fresh-identifier 'k)))
                (cont
                 (cps-proc-exp (append vars (list k))
                               (cps-of-exp body (lambda (simple)
                                                  (cps-call-exp (cps-var-exp k) (list simple))
                                                  ))
                               )
                 )
                )
              ;   (cps-of-exp body (lambda (simple)
              ;                      (let ((k (fresh-identifier 'k)))
              ;                        (cont
              ;                         (cps-proc-exp (append vars (list k))
              ;                                       (cps-call-exp (cps-var-exp k) (list simple))
              ;                                       )
              ;                         )
              ;                        )
              ;                      ))
              )
    (call-exp (rator rands)
              (cps-of-exps
               (cons rator rands)
               (lambda (simples)
                 (let ((var (fresh-identifier 'var)))
                   (cps-call-exp
                    (car simples)
                    (append
                     (cdr simples)
                     (list
                      (cps-proc-exp (list var)
                                    (cont (cps-var-exp var))
                                    )
                      )
                     )
                    )
                   ))
               )
              )
    (sum-exp (exps)
             (cps-of-exps exps (lambda (simples)
                                 (cont (cps-sum-exp simples))
                                 ))
             )
    (let-exp (var1 exp1 body)
             (cps-of-exp exp1 (lambda (simple1)
                                (cps-let-exp var1 simple1
                                             (cps-of-exp body (lambda (simple)
                                                                (cont simple)
                                                                ))
                                             )
                                ))
             )
    (letrec-exp (p-names b-varss p-bodies body)
                (let ((k-exps (map (lambda (name) (fresh-identifier 'k)) p-names)))
                  (cps-letrec-exp
                   p-names
                   (map (lambda (b-vars k) (append b-vars (list k))) b-varss k-exps)
                   (map (lambda (p-body k)
                          (cps-of-exp p-body (lambda (simple)
                                               (cps-call-exp (cps-var-exp k) (list simple))
                                               )
                                      )
                          ) p-bodies k-exps)
                   (cps-of-exp body (lambda (simple)
                                      (cont simple)
                                      ))
                   )
                  )
                )
    (else (eopl:error 'cps-of-exp "invalid expression type ~s " exp))
    )
  )

(define (cps-of-exps exps cont)
  (if (null? exps)
      (cont '())
      (let ((first (car exps)) (rest (cdr exps)))
        (cps-of-exp first (lambda (simple1)
                            (cps-of-exps rest (lambda (simples)
                                                (cont (cons simple1 simples))
                                                ))
                            ))
        )
      )
  )

(define (cps-of-simple-exp exp)
  (cases expression exp
    (const-exp (num) (cps-const-exp num))
    (var-exp (var) (cps-var-exp var))
    (diff-exp (simple1 simple2)
              (cps-diff-exp (cps-of-simple-exp simple1) (cps-of-simple-exp simple2))
              )
    (zero?-exp (simple1)
               (cps-zero?-exp (cps-of-simple-exp simple1))
               )
    ; (proc-exp (vars body)
    ;     (let ((k-exp (fresh-identifier 'k)))
    ;         (cps-proc-exp (append vars k-exp))
    ;             (cps-of-exp body
    ;                 (cps-proc-exp (vars)
    ;                 )
    ;         )
    ;     )
    ; )
    (sum-exp (simples)
             (cps-sum-exp (map cps-of-simple-exp simples))
             )
    (else (eopl:error 'cps-of-simple-exp "invalid expression type ~s " exp))
    )
  )

; (define (is-not-simple-expression? exp)
;   (not (is-simple-expression? exp))
;   )

(define (is-simple-expression? exp)
  (cases expression exp
    (const-exp (num) #t)
    (var-exp (id) #t)
    (diff-exp (exp1 exp2)
              (all-simple? (list exp1 exp2))
              )
    (zero?-exp (exp1) (is-simple-expression? exp1))
    (if-exp (exp1 exp2 exp3)
            (all-simple? (list exp1 exp2 exp3))
            )
    (proc-exp (vars body)
              (is-simple-expression? body)
              )
    (sum-exp (exps) (all-simple? exps))
    (let-exp (var exp1 body)
             (all-simple? (list exp1 body))
             )
    (letrec-exp (p-names b-varss p-bodies body)
                (all-simple? (cons body p-bodies))
                )
    (else #f)
    )
  )

(define (all-simple? exps)
  (if (null? exps)
      #t
      (and
       (is-simple-expression? (car exps))
       (all-simple? (cdr exps))
       )
      )
  )
