#lang eopl

(require "expression.rkt" "basic.rkt" "grammar.rkt")

(provide (all-defined-out))

(define-datatype type-environment type-environment?
  (empty-tenv)
  (extend-tenv
   (vars (list-of identifier?))
   (var-types (list-of type?))
   (tenv type-environment?)
   )
  )

(define (init-tenv)
  (extend-tenv (list 'i) (list (int-type))
               (extend-tenv (list 'v) (list (int-type))
                            (extend-tenv (list 'x) (list (int-type))
                                         (empty-tenv)
                                         )
                            )
               )
  )

(define (apply-tenv env search-var)
  (cases type-environment env
    (extend-tenv (vars types saved-env)
                (letrec ((loop (lambda (vars types saved-env)
                                 (if (null? vars)
                                     (apply-tenv saved-env search-var)
                                     (let ((first-var (car vars)) (first-type (car types)))
                                       (if (eqv? first-var search-var)
                                           first-type
                                           (loop (cdr vars) (cdr types) saved-env)
                                           )
                                       )
                                     )
                                 )))
                  (loop vars types saved-env)
                  )
                )
    (else (report-no-binding-found search-var))
    )
  )


(define (report-unequal-types ty1 ty2 exp)
  (eopl:error 'check-unequal-type! "Types didn't match: ~s != ~a in ~%~a"
              (type-to-external-form ty1)
              (type-to-external-form ty2)
              exp
              )
  )

(define (type-to-external-form ty)
  (cases type ty
    (int-type () 'int)
    (bool-type () 'bool)
    (proc-type (arg-types result-type)
               (list (map type-to-external-form arg-types)
                     '->
                     (type-to-external-form result-type)
                     )
               )
    )
  )

(define (type-of-program pgm)
  (cases program pgm
    (a-program (exp1) (type-of exp1 (init-tenv)))
    )
  )

(define (type-of exp tenv)
  (cases expression exp
    (const-exp (num) (int-type))
    (var-exp (var) (apply-tenv tenv var))
    (diff-exp (exp1 exp2)
              (let ((ty1 (type-of exp1 tenv)) (ty2 (type-of exp2 tenv)))
                (check-equal-type! ty1 (int-type) exp1)
                (check-equal-type! ty2 (int-type) exp2)
                (int-type)
                )
              )
    (zero?-exp (exp1)
               (let ((ty1 (type-of exp1 tenv)))
                 (check-equal-type! ty1 (int-type) exp1)
                 (bool-type)
                 )
               )
    (if-exp (exp1 exp2 exp3)
            (let ((ty1 (type-of exp1 tenv))
                  (ty2 (type-of exp2 tenv))
                  (ty3 (type-of exp3 tenv))
                  )
              (check-equal-type! ty1 (bool-type) exp1)
              (check-equal-type! ty2 ty3 exp)
              ty2
              )
            )
    (let-exp (vars exps body)
             (let ((exp-types (types-of exps tenv)))
               (type-of body (extend-tenv vars exp-types tenv))
               )
             )
    (proc-exp (vars var-types body)
              (let ((result-type (type-of body (extend-tenv vars var-types tenv))))
                (proc-type var-types result-type)
                )
              )
    (call-exp (rator rands)
              (let ((rator-type (type-of rator tenv))
                    (rand-types (types-of rands tenv)))
                (cases type rator-type
                  (proc-type (arg-types result-type)
                             (begin
                               (check-equal-type! arg-types rand-types rands)
                               result-type
                               )
                             )
                  (else (report-rator-not-a-proc-type rator-type rator))
                  )
                )
              )
    (letrec-exp (p-result-type p-name b-vars b-var-types p-body letrec-body)
                (let ((tenv-for-letrec-body (extend-tenv (list p-name) (list (proc-type b-var-types p-result-type)) tenv)))
                  (let ((p-body-type (type-of p-body (extend-tenv b-vars b-var-types tenv-for-letrec-body))))
                    (check-equal-type! p-body-type p-result-type p-body)
                    (type-of letrec-body tenv-for-letrec-body)
                    )
                  )
                )
    (else (eopl:error 'type-of "unsupported expression type ~s" exp))
    )
  )

(define (types-of exps env)
  (map (lambda (exp) (type-of exp env)) exps)
)

(define (check-equal-type! ty1 ty2 exp)
  (if (not (equal? ty1 ty2))
      (report-unequal-types ty1 ty2 exp)
      #f
      )
  )

(define (report-rator-not-a-proc-type rator-type rator)
  (eopl:error 'type-of-expression "Rator not a proc type: ~%~s~%had rator type ~s" rator (type-to-external-form rator-type))
  )
