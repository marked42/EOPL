#lang eopl

(require racket/lazy-require racket/list "basic.rkt" "value.rkt" "parser.rkt" "expression.rkt")
(lazy-require
 ["environment.rkt" (
                     init-env
                     apply-env
                     extend-mul-env
                     build-circular-extend-env-rec-mul-vec
                     environment?
                     )]
 ["store.rkt" (deref initialize-store! vals->refs setref reference?)]
 ["procedure.rkt" (apply-procedure/k procedure)])

(provide (all-defined-out))

(define (run str)
  (value-of-program (scan&parse str))
  )

(define (value-of-program prog)
  (initialize-store!)
  (cases program prog
    (a-program (exp1) (value-of/k exp1 (init-env) (end-cont)))
    )
  )

(define (value-of/k exp env cont)
  (cases expression exp
    (const-exp (num) (apply-cont cont (num-val num)))
    (diff-exp (exp1 exp2)
              (value-of/k exp1 env (cons (diff-frame-1 exp2 env) cont))
              )
    (zero?-exp (exp1)
               (value-of/k exp1 env (cons (zero?-frame) cont))
               )
    (if-exp (exp1 exp2 exp3)
            (value-of/k exp1 env (cons (if-frame exp2 exp3 env) cont))
            )
    (var-exp (var)
             (apply-cont cont (deref (apply-env env var)))
             )
    (let-exp (vars exps body)
             (value-of-exps/k exps '() env (cons (let-frame vars body env) cont))
             )
    (proc-exp (first-var rest-vars body)
              (apply-cont cont (proc-val (procedure (cons first-var rest-vars) body env)))
              )
    (call-exp (rator rands)
              (value-of/k rator env (cons (call-exp-frame rands env) cont))
              )
    (letrec-exp (p-names b-vars-list p-bodies body)
                (let ((new-env (build-circular-extend-env-rec-mul-vec p-names b-vars-list p-bodies env)))
                  (value-of/k body new-env cont)
                  )
                )
    ; list
    (emptylist-exp () (apply-cont cont (null-val)))
    (cons-exp (exp1 exp2)
              (value-of/k exp1 env (cons (cons-exp-frame-1 exp2 env) cont))
              )
    (null?-exp (exp1)
               (value-of/k exp1 env (cons (null?-exp-frame) cont))
               )
    (car-exp (exp1)
             (value-of/k exp1 env (cons (car-exp-frame) cont))
             )
    (cdr-exp (exp1)
             (value-of/k exp1 env (cons (cdr-exp-frame) cont))
             )
    (list-exp (exp1 exps)
              (value-of-exps/k (cons exp1 exps) '() env (cons (list-exp-frame) cont))
              )
    (begin-exp (exp1 exps)
               (value-of-exps/k (cons exp1 exps) '() env (cons (begin-exp-frame) cont))
               )
    (assign-exp (var exp1)
                (value-of/k exp1 env (cons (set-rhs-frame (apply-env env var)) cont))
                )
    (else (eopl:error "invalid exp ~s" exp))
    )
  )

(define (apply-cont cont val)
  (if (null? cont)
    val
    (let ((first-frame (car cont)) (saved-cont (cdr cont)))
      (cases frame first-frame
        (diff-frame-1 (exp2 saved-env)
          (value-of/k exp2 saved-env
            (cons (diff-frame-2 val) saved-cont)
          )
        )
        (diff-frame-2 (val1)
          (apply-cont saved-cont (eval-diff-exp val1 val))
        )
        (zero?-frame ()
          (apply-cont saved-cont (eval-zero?-exp val))
        )
        (if-frame (exp2 exp3 saved-env)
          (value-of/k (eval-if-exp val exp2 exp3) saved-env saved-cont)
        )
        (exps-frame (exps vals saved-env)
                   (value-of-exps/k exps (append vals (list val)) saved-env saved-cont)
        )
        (let-frame (vars body saved-env)
                   (let ((vals val))
                    (value-of/k body (extend-mul-env vars (vals->refs vals) saved-env) saved-cont)
                   )
        )
        (call-exp-frame (rands saved-env)
                        (let ((rator val))
                          (value-of-exps/k rands '() saved-env (cons (call-exp-frame-1 rator) saved-cont))
                        )
        )
        (call-exp-frame-1 (rator)
                        (let ((proc1 (expval->proc rator)) (rands val))
                          (apply-procedure/k proc1 rands saved-cont)
                        )
        )
        (cons-exp-frame-1 (exp2 saved-env)
                          (value-of/k exp2 saved-env (cons (cons-exp-frame-2 val) saved-cont))
        )
        (cons-exp-frame-2 (val1)
                         (let ((val2 val))
                          (apply-cont saved-cont (cell-val val1 val2))
                          )
                         )
        (null?-exp-frame ()
                         (apply-cont saved-cont (eval-null?-exp val))
        )
        (car-exp-frame ()
                       (apply-cont saved-cont (eval-car-exp val))
        )
        (cdr-exp-frame ()
                       (apply-cont saved-cont (eval-cdr-exp val))
        )
        (list-exp-frame ()
                        (let ((vals val))
                          (apply-cont saved-cont (build-list-from-vals vals))
                        )
        )
        (begin-exp-frame ()
                         (let ((vals val))
                          (apply-cont saved-cont (last vals))
                         )
        )
        (set-rhs-frame (ref)
                       (setref ref val)
                       (apply-cont saved-cont val)
        )
        (else (eopl:error "invalid frame type~s " first-frame))
      )
    )
  )
)

(define (eval-diff-exp val1 val2)
  (let ((num1 (expval->num val1)) (num2 (expval->num val2)))
    (num-val (- num1 num2))
    )
  )

(define (eval-zero?-exp val1)
  (let ((num (expval->num val1)))
    (if (zero? num)
        (bool-val #t)
        (bool-val #f)
        )
    )
  )

(define (eval-if-exp val1 exp2 exp3)
  (let ((exp (if (expval->bool val1) exp2 exp3)))
    exp
    )
  )

(define (end-cont) '())

(define-datatype frame frame?
  (diff-frame-1 (exp2 expression?) (saved-env environment?))
  (diff-frame-2 (val1 expval?))
  (zero?-frame)
  (if-frame (exp2 expression?) (exp3 expression?) (saved-env environment?))
  (exps-frame (exps (list-of expression?)) (vals (list-of expval?)) (saved-env environment?))
  (let-frame (vars (list-of identifier?)) (body expression?) (saved-env environment?))
  (call-exp-frame (rands (list-of expression?)) (saved-env environment?))
  (call-exp-frame-1 (rator expval?))
  (cons-exp-frame-1 (exp2 expression?) (saved-env environment?))
  (cons-exp-frame-2 (val1 expval?))
  (null?-exp-frame)
  (car-exp-frame)
  (cdr-exp-frame)
  (list-exp-frame)
  (begin-exp-frame)
  (set-rhs-frame (ref reference?))
  )

(define (value-of-exps/k exps vals env saved-cont)
  (if (null? exps)
      (apply-cont saved-cont vals)
      (let ((first-exp (car exps)) (rest-exps (cdr exps)))
        (value-of/k
         first-exp
         env
         (cons (exps-frame rest-exps vals env) saved-cont)
         )
        )
      )
  )

(define (eval-null?-exp val1)
  (cases expval val1
    (null-val () (bool-val #t))
    (else (bool-val #f))
    )
  )

(define (eval-car-exp val1)
  (cell-val->first val1)
  )

(define (eval-cdr-exp val1)
  (cell-val->second val1)
  )

(define (build-list-from-vals vals)
  (if (null? vals)
      (null-val)
      (let ((first (car vals)) (rest (cdr vals)))
        (cell-val first (build-list-from-vals rest))
        )
      )
  )
