#lang eopl

(require "type.rkt"
         "type-environment.rkt"
         "substitution.rkt"
         "unifier.rkt"
         "equal-up-to-gensyms.rkt"
         "../expression.rkt"
         "../parser.rkt"
         )

(provide (all-defined-out))

(define-datatype answer answer?
  (an-answer (ty type?) (equations equations?))
  )

(define (type-of-program pgm)
  (reset-fresh-var)
  (cases program pgm
    (a-program (exp1)
               (let ([ans (type-of exp1 (init-tenv) (empty-equations))])
                 (cases answer ans
                   (an-answer (ty equations)
                              (apply-subst-to-type ty (unify equations))
                              )
                   )
                 )
               )
    )
  )

(define (type-of exp tenv equations)
  (cases expression exp
    (const-exp (num) (an-answer (int-type) equations))
    (var-exp (var) (an-answer (apply-tenv tenv var) equations))
    (diff-exp (exp1 exp2)
              (cases answer (type-of exp1 tenv equations)
                (an-answer (ty1 equations)
                           (let ([equations (extend-equations ty1 (int-type) equations exp1)])
                             (cases answer (type-of exp2 tenv equations)
                               (an-answer (ty2 equations)
                                          (let ([equations (extend-equations ty2 (int-type) equations exp2)])
                                            (an-answer (int-type) equations)
                                            )
                                          )
                               )
                             )
                           )
                )
              )
    (zero?-exp (exp1)
               (let ([ans (type-of exp1 tenv equations)])
                 (cases answer ans
                   (an-answer (ty1 equations)
                              (let ([equations (extend-equations ty1 (int-type) equations exp)])
                                (an-answer (bool-type) equations)
                                )
                              )
                   )
                 )
               )
    (if-exp (exp1 exp2 exp3)
            (cases answer (type-of exp1 tenv equations)
              (an-answer (ty1 equations)
                         (let ([equations (extend-equations ty1 (bool-type) equations exp1)])
                           (cases answer (type-of exp2 tenv equations)
                             (an-answer (ty2 equations)
                                        (cases answer (type-of exp3 tenv equations)
                                          (an-answer (ty3 equations)
                                                     (let ([equations (extend-equations ty2 ty3 equations exp)])
                                                       (an-answer ty2 equations)
                                                       )
                                                     )
                                          )
                                        )
                             )
                           )
                         )
              )
            )
    (let-exp (var exp1 body)
             (cases answer (type-of exp1 tenv equations)
               (an-answer (exp1-type equations)
                          (type-of body (extend-tenv var exp1-type tenv) equations)
                          )
               )
             )
    (proc-exp (var otype body)
              (let ([var-type (otype->type otype)])
                (cases answer (type-of body (extend-tenv var var-type tenv) equations)
                  (an-answer (result-type equations)
                             (an-answer (proc-type var-type result-type) equations)
                             )
                  )
                )
              )
    (call-exp (rator rand)
              (let ([result-type (fresh-var-type)])
                (cases answer (type-of rator tenv equations)
                  (an-answer (rator-type equations)
                             (cases answer (type-of rand tenv equations)
                               (an-answer (rand-type equations)
                                          (let ([equations (extend-equations rator-type (proc-type rand-type result-type) equations exp)])
                                            (an-answer result-type equations)
                                            )
                                          )
                               )
                             )
                  )
                )
              )
    (letrec-exp (p-result-otype p-name b-var b-var-otype p-body letrec-body)
                (let ([p-result-type (otype->type p-result-otype)] [b-var-type (otype->type b-var-otype)])
                  (let ([tenv-for-letrec-body (extend-tenv p-name (proc-type b-var-type p-result-type) tenv)])
                    (cases answer (type-of p-body (extend-tenv b-var b-var-type tenv-for-letrec-body) equations)
                      (an-answer (p-body-type equations)
                                 (let ([equations (extend-equations p-body-type p-result-type equations p-body)])
                                   (type-of letrec-body tenv-for-letrec-body equations)
                                   )
                                 )
                      )
                    )
                  )
                )
    )
  )

(define (report-rator-not-a-proc-type rator-type rator)
  (eopl:error 'type-of-expression "Rator not a proc type: ~%~s~%had rator type ~s" rator (type-to-external-form rator-type))
  )

(define (check-program-type str)
  (type-to-external-form (type-of-program (scan&parse str)))
  )
