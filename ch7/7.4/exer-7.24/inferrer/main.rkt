#lang eopl

(require "type.rkt"
         "type-environment.rkt"
         "substitution.rkt"
         "unifier.rkt"
         "equal-up-to-gensyms.rkt"
         "../expression.rkt"
         "../parser.rkt"
         "../typed-var.rkt"
         )

(provide (all-defined-out))

(define (type-or-type-list? val)
  (or
    (type? val)
    ((list-of type?) val)
  )
)

(define-datatype answer answer?
  (an-answer (ty type-or-type-list?) (subst substitution?))
  )

(define (type-of-program pgm)
  (reset-fresh-var)
  (cases program pgm
    (a-program (exp1)
               (let ([ans (type-of exp1 (init-tenv) (empty-subst))])
                 (cases answer ans
                   (an-answer (ty subst)
                              (apply-subst-to-type ty subst)
                              )
                   )
                 )
               )
    )
  )

(define (type-of exp tenv subst)
  (cases expression exp
    (const-exp (num) (an-answer (int-type) subst))
    (var-exp (var) (an-answer (apply-tenv tenv var) subst))
    (diff-exp (exp1 exp2)
              (cases answer (type-of exp1 tenv subst)
                (an-answer (ty1 subst1)
                           (let ([subst1 (unifier ty1 (int-type) subst1 exp1)])
                             (cases answer (type-of exp2 tenv subst1)
                               (an-answer (ty2 subst2)
                                          (let ([subst2 (unifier ty2 (int-type) subst2 exp2)])
                                            (an-answer (int-type) subst2)
                                            )
                                          )
                               )
                             )
                           )
                )
              )
    (zero?-exp (exp1)
               (let ([ans (type-of exp1 tenv subst)])
                 (cases answer ans
                   (an-answer (ty1 subst1)
                              (let ([subst2 (unifier ty1 (int-type) subst1 exp)])
                                (an-answer (bool-type) subst2)
                                )
                              )
                   )
                 )
               )
    (if-exp (exp1 exp2 exp3)
            (cases answer (type-of exp1 tenv subst)
              (an-answer (ty1 subst)
                         (let ([subst (unifier ty1 (bool-type) subst exp1)])
                           (cases answer (type-of exp2 tenv subst)
                             (an-answer (ty2 subst)
                                        (cases answer (type-of exp3 tenv subst)
                                          (an-answer (ty3 subst)
                                                     (let ([subst (unifier ty2 ty3 subst exp)])
                                                       (an-answer ty2 subst)
                                                       )
                                                     )
                                          )
                                        )
                             )
                           )
                         )
              )
            )
    (let-exp (vars exps body)
             (cases answer (type-of-exps exps tenv subst)
               (an-answer (types subst)
                          (type-of body (extend-tenv* vars types tenv) subst)
                          )
               )
             )
    (proc-exp (typed-vars body)
              (let ([vars (map typed-var->var typed-vars)]
                    [var-types (map (lambda (typed-var) (otype->type (typed-var->type typed-var))) typed-vars)])
                (cases answer (type-of body (extend-tenv* vars var-types tenv) subst)
                  (an-answer (result-type subst)
                             (an-answer (proc-type var-types result-type) subst)
                             )
                  )
                )
              )
    (call-exp (rator rands)
              (let ([result-type (fresh-var-type)])
                (cases answer (type-of rator tenv subst)
                  (an-answer (rator-type subst)
                             (cases answer (type-of-exps rands tenv subst)
                               (an-answer (rand-types subst)
                                          (let ([subst (unifier rator-type (proc-type rand-types result-type) subst exp)])
                                            (an-answer result-type subst)
                                            )
                                          )
                               )
                             )
                  )
                )
              )
    (letrec-exp (p-result-otypes p-names b-typed-vars p-bodies letrec-body)
                (let ([p-result-types (map (lambda (p-result-otype) (otype->type p-result-otype)) p-result-otypes)]
                      [b-vars (map typed-var->var b-typed-vars)]
                      [b-var-types (map (lambda (b-typed-var) (otype->type (typed-var->type b-typed-var))) b-typed-vars)])
                  (let* ([tenv-for-letrec-body (get-tenv-for-letrec-body p-names b-var-types p-result-types tenv)]
                         [subst (unifer-p-bodies b-vars b-var-types p-bodies p-result-types tenv-for-letrec-body subst)])
                    (type-of letrec-body tenv-for-letrec-body subst)
                    )
                  )
                )
    )
  )

(define (unifer-p-bodies b-vars b-var-types p-bodies p-result-types tenv subst)
  (let loop ([b-vars b-vars] [b-var-types b-var-types] [p-bodies p-bodies] [p-result-types p-result-types] [subst subst])
    (if (null? b-vars)
      subst
      (let ([b-var (car b-vars)] [b-var-type (car b-var-types)] [p-body (car p-bodies)] [p-result-type (car p-result-types)])
        (cases answer (type-of p-body (extend-tenv* (list b-var) (list b-var-type) tenv) subst)
          (an-answer (p-body-type subst)
            (let ([subst (unifier p-body-type p-result-type subst p-body)])
              (loop
                (cdr b-vars)
                (cdr b-var-types)
                (cdr p-bodies)
                (cdr p-result-types)
                subst)
            )
          )
        )
      )
    )
  )
)

(define (get-tenv-for-letrec-body p-names b-var-types p-result-types tenv)
  (extend-tenv*
    p-names
    (map (lambda (b-var-type p-result-type) (proc-type (list b-var-type) p-result-type)) b-var-types p-result-types)
    tenv)
)

(define (report-rator-not-a-proc-type rator-type rator)
  (eopl:error 'type-of-expression "Rator not a proc type: ~%~s~%had rator type ~s" rator (type-to-external-form rator-type))
  )

(define (check-program-type str)
  (type-to-external-form (type-of-program (scan&parse str)))
  )

(define (type-of-exps exps tenv subst)
  (let loop ([types '()] [exps exps] [subst subst])
    (if (null? exps)
      (an-answer (reverse types) subst)
      (cases answer (type-of (car exps) tenv subst)
        (an-answer (ty subst1)
          (loop (cons ty types) (cdr exps) subst1)
        )
      )
    )
  )
)
